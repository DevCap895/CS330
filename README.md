# CS330
How do I approach designing software?

I approach designing software by clarifying requirements with stakeholders, modeling the domain into simple abstractions, and planning modular, testable components with clear interfaces before writing code. Working on the project taught me to design reusable APIs and data models and to map UI needs to database schemas using ER diagrams; I followed an iterative cycle of wireframes, small prototypes, testing, and refactoring, and I will reuse tactics like modularization, API-first thinking, rapid prototyping, test-driven validation, and regular stakeholder feedback to reduce risk and make future systems easier to maintain and scale.

How do I approach developing programs?

I approach developing programs by decomposing problems into small, testable tasks, writing clear, well-named code with automated tests and version control, integrating frequently, and using modular design and documentation so features can be validated and rolled back safely. While building the 3D scene I adopted a scene‑graph organization, separated rendering from application logic, used lazy resource loading and modular shaders/materials, and relied on profiling and asset optimizations (LODs, atlases, draw‑call reduction) to keep performance acceptable. Iteration was central: I shipped minimal prototypes, measured and fixed bottlenecks, refactored toward clearer abstractions, and added tests and automation across milestones, which shifted my workflow from rapid proof‑of‑concepts to disciplined, testable releases that supported the project’s completion.

How can computer science help me in reaching my goals?

Computer science gives you problem‑solving methods, algorithms, and software‑engineering practices to automate tasks, analyze data, prototype solutions quickly, and build scalable, reliable tools that advance your goals and career. Computational graphics and visualization add geometric reasoning, GPU/shader and performance skills, and techniques for turning data into clear visuals, enabling advanced study and the ability to create interactive tools, simulations, and dashboards that communicate complexity and improve product iteration.
